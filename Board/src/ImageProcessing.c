#include "common.h"
#include "ImageProcessing.h"
#include "include.h"

uint8 Image_Data_Black_spots[CAMERA_H];   
int    Axis_X = 0;   //获取到的是亮斑X中点 控制舵机
int    Axis_Y = 0;    //获取到的是亮斑Y中点 控制电机
extern uint8 imgbuff[CAMERA_SIZE];      //imgbuff是采集的缓冲区，img是解压后的缓冲区。
                                  
extern uint8 img[CAMERA_H*CAMERA_W]; //imgbuff用于采集图像，img用于图像处理. 

int gete_X[5]={0};
int gete_Y[5]={0};
//
//void IMAGE_PRO(void)
//{
//        unsigned int i=0;  
//	unsigned char *p=NULL;
//	int n=0;
//      
//        int j,num=0,Y=0;
//        int sum=0;
//      // Axis_Y=0;
//        img_extract((uint8 *)img,(uint8 *) imgbuff, CAMERA_H*CAMERA_W/8);    //解压
//       
////        for(j=3;j>0;j--)
////        {
////        gete_Y[j]=gete_Y[j-1];
////   
////        }
////	for (i = 0;i < CAMERA_H;i++)                                         //滤掉不连续的点
////        {               
////		p = &img[i][1];
////		while (p < &img[i][135-1])
////                {
////		  if (*(p-1) == 0xff && *p == 0x00 && *(p+1) ==0xff)
////                  {
////			  *p = 0xff;
////                  }
////                  else if (*(p-1) == 0x00 && *p ==0xff && *(p+1) ==0x00)
////                  {
////			*p = 0x00;
////                  }
////                  p++;
////		}
////	}
//        
//
//
//         //----------------------------------------获取信标灯Y坐标------------------------------------------------//
//        for(i=0;i<CAMERA_H;i++) 
//        {
//           Image_Data_Black_spots[i] = 0;//赋初值
//        }
//         //Axis_Y=0;
//        for (i = 0;i < CAMERA_H;i++)
//        {               
//          p = &img[i][1];
//          while (p < &img[i][135-1])
//            {
//		  if (*p == 0xff && *(p+1) ==0xff)
//                  {
//			 Image_Data_Black_spots[i]++;  //有亮斑不为0，
//                         //根据Image_Data_Black_spots[i]的大小判断宽度
//                  }
//                  p++;
//	    }
//          
//           if(i == 0)
//           {
//             n=Image_Data_Black_spots[0];//==0
//            }
//            else if(Image_Data_Black_spots[i] > n )
//              {
//                  n=Image_Data_Black_spots[i];  //   n为最大宽度
//                  Y = i;                   // i 应该是亮斑中心的行坐标
//              }
//             
//	}  
//        Axis_Y = Y;
//
//}
//
////----------------------------------------获取X轴坐标------------------------------------------------//
//void Get_X(void)
//  {
//    int i,j,num=0;
// 
//    int sum=0;
//    //Axis_X=0;
//    int start=0,end=0;
//    for(i=0;i<135;i++)// 将图像左右两边变黑适合计算 不会出BUG
//      {
//          img[i][0] =img[i][135-1]=0x00;  
//      }
//    for(i = 0; i < 135; i++ )
//      {
//        if(img[Axis_Y][i] == 0x00 && img[Axis_Y][i+1] ==0xff)
//        start=i;
//        if(img[Axis_Y][i] == 0xff && img[Axis_Y][i+1] ==0x00)
//        end=i;
//    
//      }
//      Axis_X=(start+end)/2;
//
//}
//
//






/*****************************************
 *  @brief      李浩蜜的二值化图像解压
 *  @since      v5.0 //  img_extract_haomi(img,imgbuff,CAMERA_SIZE);
 ****************************************/
void img_extract_haomi(uint8 *dst, uint8 *src, uint32 srclen)
{
    uint8 colour[2] = {1, 0};
    uint8 tmpsrc;
    while(srclen --)
    {
        tmpsrc = *src++;
        *dst++ = colour[ (tmpsrc >> 7 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 6 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 5 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 4 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 3 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 2 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 1 ) & 0x01 ];
        *dst++ = colour[ (tmpsrc >> 0 ) & 0x01 ];
    }
}

extern Ball_Position Ball;

/*************************************************************************
*  函数名称：Position_Calculate 
*  功能说明：小球位置计算
*  参数说明：无
*  函数返回：无
*  修改时间：2017-8-03    已测试
*************************************************************************/
void Position_Calculate()
{
  int sumX = 0,sumY = 0;
  int i,j,cnt=0;
  for(i=3;i<CAMERA_H-3;i++)
  {
    for(j=2;j<CAMERA_W-2;j++)
    {
      if(img[i*CAMERA_W+j]==0)   //如果为黑
      {
        sumX+=i;
        sumY+=j;
        cnt++;
      }
    }
  }
  if(sumX <5&&sumY<5)
  {
      Ball.now_x = 46;//中点坐标
      Ball.now_y = 6;
  }
  else
  {
      Ball.now_x = (int)(sumX /(float)cnt);
      Ball.now_y = (int)(sumY /(float)cnt);
  }
}





